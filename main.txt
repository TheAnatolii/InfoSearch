#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <filesystem>
#include <algorithm>
#include "db/MongoConnector.hpp"
#include "nlp/HtmlParser.hpp"
#include "nlp/Tokenizer.hpp"
#include "nlp/Lemmatizer.hpp"
#include "core/InvertedIndex.hpp"
#include "core/BooleanIndex.hpp"
#include "ranking/Scorer.hpp"
#include "nlp/QueryParser.hpp"

bool saveUrls(const std::string &filename, const std::vector<std::string> &urls)
{
    std::ofstream out(filename, std::ios::binary);
    if (!out.is_open())
        return false;

    size_t count = urls.size();
    out.write(reinterpret_cast<const char *>(&count), sizeof(count));

    for (const auto &url : urls)
    {
        size_t len = url.size();
        out.write(reinterpret_cast<const char *>(&len), sizeof(len));
        out.write(url.c_str(), len);
    }
    return true;
}

bool loadUrls(const std::string &filename, std::vector<std::string> &urls)
{
    std::ifstream in(filename, std::ios::binary);
    if (!in.is_open())
        return false;

    urls.clear();
    size_t count = 0;
    in.read(reinterpret_cast<char *>(&count), sizeof(count));
    urls.reserve(count);

    for (size_t i = 0; i < count; ++i)
    {
        size_t len = 0;
        in.read(reinterpret_cast<char *>(&len), sizeof(len));
        std::string url(len, '\0');
        in.read(&url[0], len);
        urls.push_back(url);
    }
    return true;
}

// ------------------------------------------------------------

int main(int argc, char *argv[])
{
    // Парсим аргументы командной строки
    bool useBooleanMode = false;
    for (int i = 1; i < argc; ++i)
    {
        if (std::string(argv[i]) == "--bool")
        {
            useBooleanMode = true;
            break;
        }
    }

    Lemmatizer lemmatizer;
    std::vector<std::string> docUrls;

    const std::string INDEX_FILE = "index.bin";
    const std::string BOOLEAN_INDEX_FILE = "boolean_index.bin";
    const std::string URLS_FILE = "urls.bin";

    std::cout << "=== Search Engine ===" << std::endl;
    std::cout << "Mode: " << (useBooleanMode ? "BOOLEAN SEARCH" : "TF-IDF SEARCH (default)") << std::endl;
    std::cout << "To switch mode, restart with --bool flag for boolean search" << std::endl;
    std::cout << std::endl;

    if (useBooleanMode)
    {
        // ========== РЕЖИМ БУЛЕВА ПОИСКА ==========
        BooleanIndex booleanIndex;
        QueryParser queryParser(nullptr, lemmatizer);

        // Загружаем булев индекс
        if (std::filesystem::exists(BOOLEAN_INDEX_FILE) && std::filesystem::exists(URLS_FILE))
        {
            std::cout << "Loading boolean index..." << std::endl;
            if (booleanIndex.load(BOOLEAN_INDEX_FILE) && loadUrls(URLS_FILE, docUrls))
            {
                std::cout << "Boolean index loaded! Docs: " << booleanIndex.getTotalDocs()
                          << ", URLs: " << docUrls.size() << std::endl;
            }
            else
            {
                std::cerr << "Failed to load boolean index." << std::endl;
                return 1;
            }
        }
        else
        {
            // Создаем булев индекс из обратного (если он есть)
            std::cout << "Boolean index not found. Creating from inverted index..." << std::endl;

            InvertedIndex tempIndex;
            if (!std::filesystem::exists(INDEX_FILE))
            {
                std::cerr << "No inverted index found either. Please rebuild indices." << std::endl;
                return 1;
            }

            if (!tempIndex.load(INDEX_FILE) || !loadUrls(URLS_FILE, docUrls))
            {
                std::cerr << "Failed to load inverted index." << std::endl;
                return 1;
            }

            std::cout << "Exporting boolean index from inverted index..." << std::endl;
            tempIndex.exportToBooleanIndex(BOOLEAN_INDEX_FILE);

            if (!booleanIndex.load(BOOLEAN_INDEX_FILE))
            {
                std::cerr << "Failed to create boolean index." << std::endl;
                return 1;
            }

            std::cout << "Boolean index created and saved!" << std::endl;
        }

        // ПОИСК В РЕЖИМЕ BOOLEAN
        std::string query;
        std::cout << "\nEnter search query (use AND, OR, NOT or И, ИЛИ, НЕ): ";
        while (std::getline(std::cin, query) && query != "exit")
        {
            auto parsedQuery = queryParser.parseBooleanOnly(query, booleanIndex);

            if (parsedQuery.allowedDocIds.empty())
            {
                std::cout << "No documents match the criteria." << std::endl;
            }
            else
            {
                std::cout << "Found " << parsedQuery.allowedDocIds.size() << " documents:" << std::endl;

                for (size_t i = 0; i < std::min(parsedQuery.allowedDocIds.size(), (size_t)10); ++i)
                {
                    uint32_t docId = parsedQuery.allowedDocIds[i];
                    std::string url = (docId < docUrls.size()) ? docUrls[docId] : "UNKNOWN_URL";
                    std::cout << i + 1 << ". " << url << std::endl;
                }
            }
            std::cout << "\nSearch: ";
        }
    }
    else
    {
        // ========== РЕЖИМ TF-IDF (ПО УМОЛЧАНИЮ) ==========
        InvertedIndex index;
        QueryParser queryParser(&index, lemmatizer);

        if (std::filesystem::exists(INDEX_FILE) && std::filesystem::exists(URLS_FILE))
        {
            std::cout << "Loading TF-IDF index..." << std::endl;
            if (index.load(INDEX_FILE) && loadUrls(URLS_FILE, docUrls))
            {
                std::cout << "Index loaded! Docs: " << index.getTotalDocs() << ", URLs: " << docUrls.size() << std::endl;
            }
            else
            {
                std::cerr << "Failed to load cache. Will re-index from DB." << std::endl;
                goto run_indexing;
            }
        }
        else
        {
        run_indexing:
            // 1. Индексация из MongoDB
            try
            {
                MongoConnector mongo("mongodb://localhost:27017", "search_engine", "pages");
                std::cout << "Starting indexing from MongoDB..." << std::endl;

                // Очищаем реестр перед новой индексацией
                docUrls.clear();

                mongo.processAllDocuments([&](const RawDocument &doc)
                                          {
                    // 1. Сохраняем URL в реестр
                    // Так как doc.id идут по порядку (0, 1, 2...), push_back кладет их корректно
                    docUrls.push_back(doc.url);

                    // 2. Стандартная обработка текста
                    std::string text = HtmlParser::getCleanText(doc.html);
                    std::vector<std::string> tokens = Tokenizer::tokenize(text);
                    
                    for (const auto& t : tokens) {
                        if (t.length() > 2) {
                            index.addTerm(lemmatizer.lemmatize(t), doc.id);
                        }
                    }
                    index.incrementDocCount(); });

                // СОХРАНЕНИЕ КЭША
                std::cout << "Indexing done. Saving files..." << std::endl;
                index.save(INDEX_FILE);
                saveUrls(URLS_FILE, docUrls); // Сохраняем ссылки

                std::cout << "All data saved." << std::endl;
            }
            catch (const std::exception &e)
            {
                std::cerr << "Error: " << e.what() << std::endl;
                return 1;
            }
        }

        // 2. ПОИСК (CLI) - TF-IDF режим
        std::string query;
        std::cout << "\nIndex ready! Enter search query: ";
        while (std::getline(std::cin, query) && query != "exit")
        {
            // 1. Парсим запрос через QueryParser
            auto parsedQuery = queryParser.parse(query);

            std::vector<SearchResult> results;

            if (parsedQuery.isBooleanQuery)
            {
                std::cout << "[Info] Boolean operators detected. Filtering with boolean logic..." << std::endl;

                if (parsedQuery.allowedDocIds.empty())
                {
                    std::cout << "No documents match the boolean criteria." << std::endl;
                }
                else
                {
                    // Запускаем Scorer только по отфильтрованным документам
                    results = Scorer::search(parsedQuery.cleanTerms, index, &parsedQuery.allowedDocIds);
                }
            }
            else
            {
                // Обычный TF-IDF поиск
                results = Scorer::search(parsedQuery.cleanTerms, index, nullptr);
            }

            std::cout << "Found " << results.size() << " documents:" << std::endl;

            for (size_t i = 0; i < std::min(results.size(), (size_t)10); ++i)
            {
                uint32_t docId = results[i].docId;
                double score = results[i].score;
                std::string url = (docId < docUrls.size()) ? docUrls[docId] : "UNKNOWN_URL";
                std::cout << i + 1 << ". [Score: " << score << "] " << url << std::endl;
            }
            std::cout << "\nSearch: ";
        }
    }

    return 0;
}